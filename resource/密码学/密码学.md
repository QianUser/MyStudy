# 密码学（cryptography）

密码学包括密码分析学（cryptanalysis）与密码编码学（cryptology），前者研究如何破解密码，后者研究如何设计密码。

## 密码（cipher）与编码（code）

密码是对消息逐字符或逐位的转换，编码则是使用另一个词或符号来代替一个词。编码学有着光荣的历史，但是现在已经不再被使用了。

### 例

历史上最成功的编码系统是二次世界大战中美国军队在太平洋战场上使用的编码，他们让纳瓦霍（Navajo）印第安人使用纳瓦霍语来交流军事术语。纳瓦霍语是一门以音调为主的语言，非常复杂，而且没有书面形式，日本方面对此一无所知。美国破译了日本的编码而日本从来没有破解出纳瓦霍编码，这为美国在太平洋战争中获胜起到关键作用。

## 密码学基本模型

![密码学基本模型](资源\密码学基本模型.png)

待加密的消息被称为明文（plaintext），它经过一个以加密密钥（key）为参数的函数变换，变换的结果被称为密文（ciphertext），可通过无线电或通信员传送出去。接收者将密文经过一个以解密密钥为参数的函数变换得到明文。入侵者（intruder）可以精确复制整个密文，但是他不知道解密密钥是什么，因此无法轻松地对密文解密。被动入侵者（passive intruder）只是对信道进行监听并记录消息，而主动入侵者（active intruder）还可以将消息在以后某个时候回放出来，插入他自己的消息或在消息到达接收者前更改消息。

假设明文为$P$，密文为$C$，加密密钥为$K_1$，解密密钥为$K_2$，加密函数为$E$，解密函数为$D$。则加密过程为：$C=E_{K_1}(P)$，解密过程为$P=D_{K_2}(C)$。由此得到：$D_{K_2}(E_{K_1}(P))=P$。其中密钥被写成下标形式从而与消息本身区分开。某些情况下，密钥不被显式地表示，此时加密函数与解密函数隐含了密钥。

## 密码学研究问题

密码学涉及的问题包括保密（secrecy）、认证（authentication）、不可否认性（nonrepudiation）和完整性控制（integrity control）等。

保密也称为机密（confidentiality），其目的是保证消息不被未被授权用户访问。

认证的目的是确认通信方的身份，即一个进程验证与其通信的对方是其所期望的实体而不是假冒者的过程。

不可否认性涉及签名，防止对方否认其发送的消息。

完整性控制的目的是确定被接收的消息是真实的而不是在传输过程中被恶意攻击者篡改过的伪造消息。

## 密码学基本原理：Kerckhoff原理（Kerckhoff's principle)

所有的密码算法必须是公开的，只有密钥是保密的。

企图使算法保持秘密的做法被称为安全模糊（security by obscurity），这种做法永远不会奏效，否则当老方法被泄漏或认为被泄漏后就需要大量的精力来发明、测试与安装新的算法，这是不现实的。并且当算法已不再保密时认为它仍然是保密的将会带来很大危害。

将算法公开，可以让密码设计者与密码学专家进行交流探讨。这些密码学家期望能够破解密码算法从而发表论文来证明自己多聪明。如果一个密码算法公开后，很多专家试图对其破解但很久都没有成功，那么这个算法就可能是很可靠的。

## 两个基本的密码学原则

### 冗余度

所有被加密的消息必须包含一定的冗余信息。

增加冗余度也会使得密码分析者更加容易破解消息，因为分析者可以一定程度上判断出明文的模式，区分出有效消息与无效消息。因此冗余信息最好具有一定的复杂性，例如使用密码散列（消息摘要）。

#### 例

假设一家邮政公司负责响应客户的订购请求并向客户邮寄相应的产品。每条订购消息包含16个字节的顾客名与3字节的数据字段（其中1字节表示购买数量，2字节表示产品编号）。3字节的数据字段用非常长的密钥进行加密且只有顾客与公司知道该密钥。尽管该邮政公司的员工不知道密钥，但是由于没有冗余度，某个不安好心的员工可以使用随机数来代替每条被加密的数据字段，并且很可能得到的仍是有效的订购信息（尽管该员工不知道其代表什么），这样计算机就会打印一些本不需要的发货指令并造成大量麻烦。通过使用冗余度，如将订购消息扩展到12个字节，其中前9个字节必须为0，并加密订购消息，员工就无法使用随机数替代最后3字节了，因为解密后几乎不可能得到有效信息（即解密后前9字节几乎不可能全0）。

未加冗余信息的订购消息难以被破解，因为分析者难以判断其尝试解密后的明文是否是真实的明文；但是加冗余信息后，若解密后的明文前9个字节不为全0，则可判断其不是真实的明文，否则极有可能是真实的明文。

### 新鲜度

必须采取某些措施保证每条接收到的消息可被验证是新鲜的，否则主动入侵者就可能重放旧的消息。即需要采取某些措施对抗重放攻击。

一种措施是在消息中添加时间戳。假设时间戳规定的有效时间段为$t$，那么接收方只需要在$t$时间段内保留该消息，并在这期间拒绝新的重复消息。所有不在$t$时间段内的消息均被拒绝，一般$t$限定为截止时间，因此这些消息因为太老而被拒绝。

#### 例

继续上一个例子，该员工还可以不断令计算机重放该消息，从而发送多个订购消息。因此在订购消息中，需要通过添加时间戳等方式对抗重放攻击。

# 加密算法

## 传统加密算法

### 替代密码（substitution cipher）

在替代密码中，每个字母或每组字母被另一个字母或另一组字母替代。

#### 凯撒密码（Caesar cipher）

凯撒密码是一种替代密码，是最古老的加密算法之一，因Julius Caesar而得名。在该方法中，明文中每个字母被循环顺序移动$k$位。在凯撒的方案中，a变成D，b变成E，……，z变成C。凯撒密码欺可能骗过庞培（Pompey），但自那以后再也没能骗过其他人。

#### 单字母替换（monoalphabetic substitution cipher）

单字母替换是通用的替代密码模式，即使用另一个字母或符号替代当前字母或符号。

#### 破解方法

该加密方案容易遭受统计攻击。攻击者可以统计字母、字母组合或词语等在明文中的出现概率或模式，然后计算字母、字母组合在密文中出现的频率或模式，通过其相似性试探出明文。

##### 例

英语中，e是最常见的字母，如果密文中出现大量的T，则可猜测其在明文中为e。英语中最常见的三字母组合为the，若密文中大量出现ZIT，则可判断其为Z在明文中为t，I在明文中为h，T在明文中为e；或者若以计算出Z、T的明文表示，通过发现三字母组合tIe很常见，那么判断I在明文中为h。

##### 例

假设以下是一家会计事务所的密文（每5个字符分为一组）且采用替代密码加密：

CTBMN BYCTC BTJDS QXBNS GSTJC BTSWX CTQTZ CQVUJ QJSGS TJQZZ MNQJS VLNSX VSZJU JDSTS JQUUS JUBXJ DSKSU JSNTK BGAQJ ZBGYQ TLCTZ BNYBN QJSW

在会计事务所中，一个可能出现的单词为financial，该单词中有一个重复单词i，且两个i之间有4个其他字母。我们在密文中找到相隔4个未知的重复字母，分别出现在位置6、15、27、31、42、48、56、66、70、71、76和82处，其中只有位置31与42处有正确的“n”位置（financial中两个n的位置）重复出现在正确的位置上，又只有位置31处有正确的“a”位置，因此判断financial从位置30开始。以此为出发点，使用英语文本的统计特性并查找推断几乎被完整推断的单词，可以推导出密钥。明文如下（A未知）：

in our opinion the afore mentioned financial statement accurately reflects the net assets of the western womA at company incorporated.

### 置换密码（Transposition cipher）

在置换密码中，明文的字母被重新排序。

#### 固定长度块

有些置换密码接受固定长度的块作为明文输入并输出固定大小的块作为密文。该密码可以通过给定一个指明字符输出顺序的列表来实现。

#### 列换位（columnar transposition）

列换位使用一个不包含任何重复字母的单词或短语作为密钥，密钥用于对列顺序进行排序。过程是：首先将明文按照行的顺序书写，每行字母数目一定，必要时可以填充行末剩余列；密文则按照列的顺序书写，其中密钥中每个字母对应列，决定列的排序。密钥中越靠近字母表起始位置的字母所对应的列在密文中出现越靠前。

##### 例

明文：please transfer one million dollars to my Swiss bank account six two two

列换位过程：

| M    | E    | G    | A    | B    | U    | C    | K    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 7    | 4    | 5    | 1    | 2    | 8    | 3    | 6    |
| p    | l    | e    | a    | s    | e    | t    | r    |
| a    | n    | s    | f    | e    | r    | o    | n    |
| e    | m    | i    | l    | l    | i    | o    | n    |
| d    | o    | l    | l    | a    | r    | s    | t    |
| o    | m    | y    | s    | w    | i    | s    | s    |
| b    | a    | n    | k    | a    | c    | c    | o    |
| u    | n    | t    | s    | i    | x    | t    | w    |
| o    | t    | w    | o    | a    | b    | c    | d    |

密文：AFLLSKSOSELAWAIATOOSSCTCLNMOMANTESILYNTWRNNTSOWDPAEDOBUOERIRICXB

也可以使用固定长度块的方式实现此过程，此时将其看做一个64字符块的密码，其字符输出顺序的列表为：4、12、20、28、36、44、52、60、5、13、……、62。

#### 破解方法

密码分析者首先要确定密文采用置换密码加密。如果发现密文中每个字母的出现频率与正常明文中字母出现频率一致，则其很可能采用置换密码加密。

若采用列换位，接下来要判断列的数目。很多情况下这可以通过上下文被猜到。例如密码分析者怀疑消息中有短语“million dollars”，他发现两字母组合MO、IL、LL、LA、LR与OS是短语回绕的结果，这可能是因为它们在短语中被一段等于密钥长度的距离隔开，因此可以猜测密钥长度为7。对于不同的密钥长度，密文中都有不同的两字母组合的回绕，通过检查不同的可能性，密码分析者可以确定密钥长度。

若采用列换位，最后要确定列的顺序。假设有$k$列，依次检查$k(k-1)$列的两字母组合是否和正常英语明文中两字母组合的出现频率一致。最佳的两字母组合对应的列被认为是相邻的两列；接下来尝试依次尝试将剩下的每列作为这两列的后继列，将两字母与三字母组合出现频率与正常英语明文中最匹配的三列组合作为后继。这个过程一直持续知道找到所有列的潜在顺序，并验证其是否正确。

### 一次性密钥（one-time pad）

该方法选择随机位串作为密钥，输出密钥与明文位串的异或作为密文。

这样的密文是不可能被破解的，因为在足够大的密文样本中，每个字母或每个任意数量的字母组合的出现频率都是相同的，根据信息理论，密文消息中没有任何信息，因为给定长度的所有可能的明文都是同样可能的。因此一次性密钥可以抵挡任何攻击，无论入侵者的计算能力有多强大。

一次性密钥有很多缺点。一次性密钥无法被记忆，因此发送方与接收方必须携带书面的密钥副本，如果一方被敌人捕获，则密钥很可能被泄漏；一次性密钥的数量与长度均有限，因此可传输的数据总量受密钥数量（与长度）的限制；一次性密钥对字符丢失或插入非常敏感，如果发送方与接收方失去同步，则之后的所有数据都会变成垃圾。

随着计算机的出现，可以使用DVD等介质并配合一些障眼法传送一次性密钥，但是操作上很繁琐，导致其实用性大大降低。

#### 例

对于消息“I love you“使用一次性密钥加密。

首先，将消息转化为7位ascii码表示形式：1001001 0100000 1101100 1101111 1110110 1100101 0100000 1111001 1101111 1110101 0101110，随机选择一个同等长度位串作为一次性密钥： 1010010 1001011 1110010 1010101 1010010 1100011 0001011 0101010 1010111 1100110 0101011，最后输出异或得到的密文： 0011011 1101011 0011110 0111010 0100100 0000110 0101011 1010011 0111000 0010011 0000101。密码分析者可以试验所有的可能的一次性密钥以查看其产生的明文，如使用：1011110 0000111 1101000 1010011 1010111 0100110 1000111 0111010 1001110 1110110 1110110，得到1000101 1101100 1110110 1101001 1110011 0100000 1101100 1101001 1110110 1100101 1110011，即”Elvis lives“，结果似是而非。因为对于某个密文，总存在一次性密钥，可以产生任意的明文，密码分析者无法判断其得到的明文是否是原来的明文。

## 对称密钥算法（symmetric key algorithm）

对称密钥算法使用同样的密钥完成加密与解密。

### P盒（P-box）与S盒（S-box）

P盒与S盒实现置换与替代操作，一般为了速度使用硬件实现。

P盒用于置换输入。通过使用适当的内部连线方式，P盒可以执行任意置换操作且可以达到光速，因为不涉及任意的计算过程，只是信号被传播。

S盒用于替代输入，S盒内嵌P盒用于将输入替代为输出。通过对P盒使用适当的内部连线方式，S盒可以执行任意替代操作。因为S盒可以用硬件来直接构造，速度极快。

将P盒与S盒进行若干叠加可构成乘积密码（product cipher）。一般由P盒与若干S盒交替操作若干次，这些S盒自顶向下堆叠在一起，因为多个小的S盒比一个大的S盒容易实现（连线数更少）。乘积密码一般将$k$位输入转换为$k$位输出，$k$的典型值为64到256。通常起始与末尾均为置换操作。

#### 例

![P盒与S盒](资源\P盒与S盒.png)

图（a）是P盒，用于置换3位输入。假设输入自顶向下为01234567，则P盒输出36071245（表示输入的第1项变成输出的第3项，输入的第2项变成输出的第5项，……）。

图（b）是S盒，3位的明文输入会产生3位的密文输出。首先，3位的输入导致从8根输入线中选择一根线并将其设置为1，其他的线均设置为0；然后，输入进入一个P盒；最后，选中的输出线路再次被编码为二进制成为3位输出。假设输入自顶向下为01234567，则输出为24506713。这里采用十进制表示，实际每个数字使用的是二进制表示。

图（c）是乘积密码，包含7个物理步骤。首先对12根输入线做置换操作，随后12位的输入分为4组，每组3位使用4个S盒进行替代操作，如此重复下去直到输出。

### 数据加密标准（data encryption standard， DES）

DES是IBM开发的、美国政府于1977年1月采纳的算法，并作为加密非机密信息的官方标准，是一种乘积密码。DES已不安全，但是其变体三重DES仍然有用。

#### DES

DES使用56位密钥加密64位数据块。其中每7位附加一个校验码，使得1的总数为奇数。因此一共组成64位数据，记为$K$，其中$K_i$表示$K$的第$i$位，若$i\mod 8=0$，则其为校验位。

对于每个数据块state，其加密过程如下，一共16轮：

```
keySub()
IPSub(state)
for i = 1 to 16:
    ESub(state, i)
    SRep(state)
    PSub(state)
IPEndSub(state)
```

解密是加密的逆过程，其过程如下：

```
IPSub(state);
for i = 1 to 16:
    ESub(state, 16 - i)
    SRep(state)
    PSub(state)
IPEndSub(state)
```

加密与解密都是对state不断变换的过程，加密时，state初始为明文；解密时，state初始为密文。下面使用$K$表示密钥，$M$表示处于某一变换状态的state。

56个常数$PC\_1_i,1\leq i\le56$如下：

```
57, 49, 41, 33, 25, 17, 9,
1, 58, 50, 42, 34, 26, 18,
10, 2, 59, 51, 43, 35, 27,
19, 11, 3, 60, 52, 44, 36,
63, 55, 47, 39, 31, 23, 15,
7, 62, 54, 46, 38, 30, 22,
14, 6, 61, 53, 45, 37, 29,
21, 13, 5, 28, 20, 12, 4,
```

48个常数$PC\_2_i,1\leq i\le56$如下：

```
14, 17, 11, 24, 1, 5, 3, 28,
15, 6, 21, 10, 23, 19, 12, 4,
26, 8, 16, 7, 27, 20, 13, 2,
41, 52, 31, 37, 47, 55, 30, 40,
51, 45, 33, 48, 44, 49, 39, 56,
34, 53, 46, 42, 50, 36, 29, 32
```

16个常数$Shift_i,1\leq i\leq16$如下：

```
1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1
```

64个常数$IP_i,1\leq i\leq64$如下：

```
58, 50, 42, 34, 26, 18, 10, 2,
60, 52, 44, 36, 28, 20, 12, 4,
62, 54, 46, 38, 30, 22, 14, 6,
64, 56, 48, 40, 32, 24, 16, 8,
57, 49, 41, 33, 25, 17, 9, 1,
59, 51, 43, 35, 27, 19, 11, 3,
61, 53, 45, 37, 29, 21, 13, 5,
63, 55, 47, 39, 31, 23, 15, 7
```

48个常数$E_i,1\leq i\leq48$如下：

```
32, 1, 2, 3, 4, 5,
4, 5, 6, 7, 8, 9,
8, 9, 10, 11, 12, 13,
12, 13, 14, 15, 16, 17,
16, 17, 18, 19, 20, 21,
20, 21, 22, 23, 24, 25,
24, 25, 26, 27, 28, 29,
28, 29, 30, 31, 32, 1
```

8个S盒$S^i,1\leq i\leq8$如下，每个S盒64位，被组织成$4×16$的矩阵。

```
14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7,
0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8,
4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0,
15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13
```

```
15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10,
3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5,
0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15,
13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9
```

```
10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8,
13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1,
13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7,
1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12
```

```
7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15,
13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9,
10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4,
3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14
```

```
2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9,
14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6,
4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14,
11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3
```

```
12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11,
10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8,
9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6,
4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13
```

```
4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1,
13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6,
1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2,
6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12
```

```
13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7,
1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2,
7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8,
2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11
```

32个常数$P_i,1\leq i\leq32$如下：

```
16, 7, 20, 21, 29, 12, 28, 17,
1, 15, 23, 26, 5, 18, 31, 10,
2, 8, 24, 14, 32, 27, 3, 9,
19, 13, 30, 6, 22, 11, 4, 25
```

64个常数$IP^{-1}_i,1\leq i\leq64$如下：

```
40, 8, 48, 16, 56, 24, 64, 32,
39, 7, 47, 15, 55, 23, 63, 31,
38, 6, 46, 14, 54, 22, 62, 30,
37, 5, 45, 13, 53, 21, 61, 29,
36, 4, 44, 12, 52, 20, 60, 28,
35, 3, 43, 11, 51, 19, 59, 27,
34, 2, 42, 10, 50, 18, 58, 26,
33, 1, 41, 9, 49, 17, 57, 25
```

##### 密钥置换（keySub）

将$K$通过$PC\_1$进行置换得到$K^0$，即$K^0$的第$i$位$K^0_i=K_{PC\_1_{i}}$。下文的置换操作同理。得到的$K^0$一共56位。

令$C_0$表示$K^0$的左28位，$D_0$表示$K^0$的右28位。然后生成$C_i,1\leq i\leq16$与$D_i,1\leq i\leq16$：
$$
C_i=S^{Shift_i}(C_{i-1}),1\leq i\leq16\\
D_i=S^{Shift_i}(D_{i-1}),1\leq i\leq16\\
$$
其中，$S^n$表示循环左移$n$位。

令$C_iD_i,1\leq i\leq16$，表示$C_i$与$D_i$拼接后的结果。接下来将每个$C_iD_i$通过$PC\_2$进行置换得到$K^i,1\leq i\leq16$。

##### IP置换（IPSub）

将$M$通过$IP$进行置换得到$M'$，令$M\leftarrow M'$，$M$被更新。

##### E扩展置换（ESub）

将$M$分成两部分，令$M^L$表示$M$的左32位，$M^R$表示$M$的右32位。然后将$M^R$通过$E$进行置换得到$M^{R'}$，令$M^R\leftarrow M^{R'}$。这样$M^R$被扩展为48位，也就是将$M^R$组织成$8×4$的矩阵，然后在矩阵的每行的第一列前添加上一行最后一位，在矩阵每行的最后一列添加下一行的第一位。第一行的上一行为最后一行，最后一行的下一行为第一行。

将$M^{R'}$与$K^i$进行异或得到新的$M^R$，其中$i$为该函数的第2个参数。

##### S盒替代（SRep）

将$8×6$的矩阵$M^R$通过8个S盒进行替代得到$8×4$的矩阵$M^{R'}$，令$M^R\leftarrow M^{R'}$。替代过程如下：$M^{R'}$的第$i$行的二进制数值等于$S^i$的第$r$行第$c$列的数值，其中$r$表示$M_R$的第$i$行的高低两位拼接成的二进制数值加1，$c$表示$M_R$的第$i$行的中间四位拼接成的二进制数值加1。这是DES的关键步骤，是唯一非线性的运算。

##### P盒置换（PSub）

将$M_R$通过$P$进行置换得到$M^{R'}$，令$M^R\leftarrow M^{R'}$。

然后将每轮开始前的$M$的左32位与$M^R$进行异或，之后交换每轮开始前的$M$的左32位、右32位，得到新的$M$，作为下一轮开始前的$M$。

##### $IP^{-1}$末置换（IPEndSub）

$IP^{-1}$末置换是IP置换的逆过程。交换$M$的左32位、右32位，将结果通过$IP^{-1}$进行置换得到最终密文。这是16轮后的最终步骤，相当于第16轮P盒置换没有交换$M$的左右两部分，同时$IP^{-1}$置换也没有交换$M$的左右两部分。

#### 三重DES（Triple DES）

三重DES使用2个密钥$K_1$与$K_2$与3个步骤加密，其目的是增加密钥长度。第1步按照常规方式使用$K_1$执行DES加密，然后使用$K_2$执行DES解密，最后使用$K_1$执行DES加密。

之所以使用112位而不是168位密钥，是因为这样一共有112位密钥，一般认为对于常规的商业应用已足够，且过多的密钥会带来管理与传输的不必要开销。

之所以使用EDE（加密-解密-加密）模式，而不是EEE（加密-加密-加密）模式，是为了兼容常规的DES，只要设置$K_1=K_2$，则三重DES等价于常规的DES。

### 高级加密标准（advanced encryption standard，AES）

美国国家标准及技术委员会（NIST）发起的、世界各地研究人员参与竞赛的加密标准。要求如下：

- 算法必须是对称的块密码。

- 所有设计必须公开。

- 必须支持128、192、256位密钥。

- 可采用软件或硬件实现。

- 算法必须公有或毫无歧视地授权给大众使用。

#### Rijndael

Rijndael是在竞赛中胜出的AES加密标准，其支持的密钥长度和块长度从128位到256位且是32位的倍数，密钥长度和块长度可以独立选择。由于AES规定块长度为128位，因此密钥长度必须为128、192、256位。事实上，AES提供两个变种：（1）使用128位密钥加密128位数据块；（2）使用256位密钥加密128位数据块。

#### AES-128

AES-128使用128位密钥加密128位数据块。对于每个数据块state，其加密过程如下：

```
keyExpansion()
addRoundKey(state, 0)
for i = 1 to 9:
	subBytes(state)
	shiftRows(state)
	mixColumns(state)
	addRoundKey(state, i)
subBytes(state)
shiftRows(state)
addRoundKey(state, 10)
```

解密是加密的逆过程，其过程如下：

```
addRoundKey(state, 10)
for i = 1 to 9:
	invShiftRows(state)
	invSubBytes(state)
	addRoundKey(state, 10 - i)
	invMixColumns(state)
invSubBytes(state)
invShiftRows(state)
addRoundKey(state, 0)
```

加密与解密都是对state不断变换的过程，加密时，state初始为明文；解密时，state初始为密文。下面使用$K$表示密钥，$M$表示处于某一变换状态的state。

$K$与$M$均被分为16个字节，记为$K_i,0\leq i<16$与$S_i,0\leq i<16$，分别表示$K$与$M$的第$i+1$个字节。$K$与$M$分别被组织成$4×4$的矩阵，记为$K_{i,j}$与$M_{i,j},0\leq i<4,0\leq j<4$。其中$K_{i,j}$表示$K_{i+4×j}$，其中$M_{i,j}$表示$M_{i+4×j}$。

10个常数$rcon_i,0\leq i<10$如下：

```
0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000,
0x20000000, 0x40000000, 0x80000000, 0x1B000000, 0x36000000
```

256个常数$S_i,0\leq i<256$如下：

```
0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5,
0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0,
0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC,
0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A,
0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0,
0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B,
0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85,
0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,
0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17,
0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88,
0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C,
0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9,
0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6,
0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E,
0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94,
0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68,
0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
```

256个常数$invS_i,0\leq i<256$如下：

```
0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38,
0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87,
0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D,
0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2,
0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16,
0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA,
0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A,
0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02,
0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA,
0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85,
0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89,
0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20,
0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31,
0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D,
0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0,
0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26,
0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
```

##### 密钥扩展（keyExpansion）

密钥扩展根据$K$生成$W$，其中$W$为$4×11$的矩阵。使用$W_{,n}$表示$W$的第$n+1$列，$K_{,n}$表示$K$的第$n+1$列，有：
$$
W_{,n}=K_{,n},0\leq n<4\\
W_{,n}=W_{,n-4}⊕W_{,n-1},n\geq 4,n\mod 4\neq0 \\
W_{,n}=W_{,n-4}⊕mix(W_{,n-1})⊕rcon_{\lfloor n/4\rfloor-1},n\geq 4,n\mod4=0
$$
其中$mix(x)=subWord(rotWord(x))$，$rotWord(x)$表示将$x$循环左移一字节，此处按列左移（即循环上移一字节），$subWord(x)$将$x$的每个字节$x_i$替换为$S_{x_i}$。$mix(x)$不会修改$x$，而是返回在$x$副本上操作的结果。

##### 轮密钥加（addRoundKey）

$addRoundKey(M,i)$将$M$替换为$M⊕W_{,4×i:4×i+4}$。其中$W_{,i:j}$表示$W$的第$i$列到第$j-1$列组成的矩阵。$⊕$表示对应位置字节的异或（字节的异或即对应位置比特的异或）。

##### 字节替换（subBytes）与逆字节替换（invSubBytes）

字节替换将$M_{i,j},0\leq i<4,0\leq j<4$替换为$S_{M_{ij}}$。

逆字节替换将$M_{i,j},0\leq i<4,0\leq j<4$替换为$invS_{M_{ij}}$。

##### 行移位（shiftRows）与逆行移位（invShiftRows）

行移位保持矩阵$M$的第1行不变，将其第2行循环左移1字节，第3行循环左移2字节，第4行循环左移3字节。

逆行移位保持矩阵$M$的第1行不变，将其第2行循环右移1字节，第3行循环右移2字节，第4行循环右移3字节。

##### 列混合（mixColumns）与逆列混合（invMixColumns）

列混合过程如下：
$$
\begin{bmatrix}
2&3&1&1\\
1&2&3&1\\
1&1&2&3\\
3&1&1&2
\end{bmatrix}
\begin{bmatrix}
M_{0,0}&M_{0,1}&M_{0,2}&M_{0,3}\\
M_{1,0}&M_{1,1}&M_{1,2}&M_{1,3}\\
M_{2,0}&M_{2,1}&M_{2,2}&M_{2,3}\\
M_{3,0}&M_{3,1}&M_{3,2}&M_{3,3}\\
\end{bmatrix}
$$
逆列混合过程如下：
$$
\begin{bmatrix}
14&11&13&9\\
9&14&11&13\\
13&9&14&11\\
11&13&9&14
\end{bmatrix}
\begin{bmatrix}
M_{0,0}&M_{0,1}&M_{0,2}&M_{0,3}\\
M_{1,0}&M_{1,1}&M_{1,2}&M_{1,3}\\
M_{2,0}&M_{2,1}&M_{2,2}&M_{2,3}\\
M_{3,0}&M_{3,1}&M_{3,2}&M_{3,3}\\
\end{bmatrix}
$$
其中，矩阵加法与乘法都是定义在伽罗华域上的二元运算，矩阵加法等同于异或。

## 公开密钥算法（public-key algorithm）

公开密钥（或简称为公钥）算法使用不同的密钥完成加密与解密。

在公钥密码（public-key cryptography）中，加密密钥为公钥（public key），是公开的；解密密钥为私钥（private key），是保密的。同样地，私钥（secret key）可用来表示秘密的密钥，在不混淆的情况下不作区分。

公钥密码系统由Diffie与Hellman于1976年提出，在他们的提案中，公钥密码系统的加密算法$E$与解密算法$D$必须满足三个条件：

- $D(E(P))=P$，其中$P$为被加密的明文。该条件保证被加密的消息可以被解密。
- 从$E$推断出$D$极为困难。该条件保证私钥的保密性。
- $E$不能被选择明文破解。

在相同安全性要求下，对相同的明文，公钥算法加解密的速度一般远慢于对称密钥算法加解密的速度，因此一般不用于加解密大量数据，而是被广泛用于密钥分发等。

### RSA

RSA是最重要的公钥算法，由Rivest、Shamir与Adleman于1978年发明。

密钥生成过程：

1. 选择两个大素数$p$与$q$（二进制表示至少有几百位，典型情况下为1024位）。
2. 计算$n=p×q$与$\phi(z)=(p-1)×(q-1)$。
3. 选择与$\phi(z)$互素的数$e$，一般不用很大，计算其关于$\phi(z)$的乘法逆元$d$，即$e×d\equiv1\mod\phi(z)$。
4. 将$(e,n)$公开，作为公钥；将$(d,n)$保密，作为私钥。

加密与解密过程：

- 加密$P$得到$C$：$C=P^e\mod n$。
- 解密$C$得到$P'$：$P=C^d\mod n$。

注意$P$与$P'$只是模$n$相等。若$0\leq P<n$，则$P=P'$。

### 公钥管理

在公开密钥算法中，一方如何获取另一方的公钥是个问题。如果Bob将自己的公钥放在自己的Web站点上，当Alice试图通过该站点获取Bob的公钥时，Trudy可能截获该请求并返回给Alice一个伪造的主页，其中Bob的公钥被替换为Trudy的公钥。这样Alice发送消息时，Trudy就能对其解密，且其可以对解密后的消息使用Bob的公钥重新加密后发给Bob从而不被暴露，甚至可以在这之前对消息做一些修改。

一种公钥管理方案是设想有一个密钥分发中心（key distribution center，KDC）全天根据客户需求提供在线公钥服务。但是该方案可扩展性差，且如果它停止工作，则整个Internet安全性将突然停止。

#### 证书

实际被使用的公钥管理方案是设立认证中心（certification authority，CA），其负责证明公钥所属权。

在该方案中，某个实体想要发布其公钥，则其必须向CA提供身份证明信息与公钥，CA给其颁发一个证书（包含身份证明与公钥等），并且CA使用自己的私钥对证书的消息摘要进行签名。这样该实体得到一个证书与对证书消息摘要的签名。

证书可以与属性（attribute）绑定。在这种情况下，公钥表达特定含义并与与之相关的实体绑定（例如和成年人绑定，因此只有成年人知道私钥）。典型情况下，证书持有者将其发送给网站、对年龄较为敏感的进程等，然后网站、进程等生成一个随机数，并用证书中的公钥对其加密返回给持有者，如果持有者能够解密之，则说明持有者具有私钥，具备证书中声明的属性。另一个例子是在面向对象的分布式系统中，每个对象有多个方法。对象所有者向每个顾客提供一个证书，证书中的位图表明顾客允许调用哪些方法，并用签名过的证书将位图与公钥绑定。类似地，证书持有者需要证明自己持有相应的私钥从而允许执行位图中指定的方法，这种方案无需暴露持有者身份。

#### 证书格式

X.509是被ITU设计并批准的专门针对证书格式的标准，其深受OSI的影响并借用了OSI领域中一些糟糕的特性，但其最终被IETF采用。

![X.509证书的基本字段](资源\X.509证书的基本字段.png)

### 公钥基础设施（public key infrastructure，PKI）

由一个CA来颁发全世界所有的证书是不切实际的，其会不堪重负且会成为中心故障点。因而需要公钥基础设施来实现公钥管理。公钥基础设施含有多个组件，包括用户、CA、证书与目录，其作用是提供一种方法将这些组件有序地组织在一起，并定义了各种文档标准与协议标准。

![分层PKI与证书链](资源\分层PKI与证书链.png)

一种PKI将CA分层组织。图中显示三个层次。上一层次的CA为下一层次的CA颁发证书。最顶级的CA root证明第二级CA区域管理机构（regional authority，RA）（非标准术语），第二级CA又证明第三级CA。

假设Alice需要Bob的公钥以便与其通信，其找到包含Bob公钥的证书，其由CA 5签过名。Alice需要证明CA 5的合法性（其公钥不是被伪造的），因而CA 5返回其从RA 2那里获得的证书。同样Alice需要证明RA 2的合法性，因而CA 5返回由Root签名的证书。这样Alice就可确信其真正拿到Bob的公钥。这种由底向上回溯到根的证书链有时被称为信任链（chain of trust）或证书路径（certification path）。

PKI假设根CA的公钥是公开且被普遍承认的，例如浏览器可能在发行的时候已预装了根的公钥。根CA并非只有一个，每个根有其自己的RA与CA。现代浏览器在安装时已预加载了多个根的公钥。根CA有时被称为信任锚（trust anchor）。当然，根CA的可靠性与选择由浏览器厂商与用户来决定。

当Alice请求Bob的公钥时，Bob可以将CA 5与RA 2的证书与其证书共同返回以避免联系CA 5与RA 2，这样可以在本地完成验证操作。

#### 目录（Directories）

证书与证书链可以存放在证书所有者那里，这样做很安全但不方便，也可以将DNS做成一个证书目录，DNS在返回IP地址时返回用户完整的证书链，也有人认为应该使用专门的目录管理器来管理证书。

#### 证书撤销

证书也有有效期或会因一些因素被撤销。处理证书撤销的方法是让CA定期发布一个证书撤销列表（certificate revocation list），该CRL列出所有已被撤销的证书序列号。由于证书包含了过期时间，故CRL只需包含那些尚未过期的证书的序列号，一旦证书过期时间到，则证书自动失效。因此不必区分已过期证书与被撤销证书。被撤销的证书也可能被恢复为有效证书。

证书可撤销与恢复的特性导致一个用户每次在使用证书前必须先要获得CA的CRL，以确定该证书是否撤销。即使该证书不在CRL中，也可能在CA发布CRL后刚刚被撤销，因此保守办法是每次使用证书询问CA该证书是否被撤销。

CRL可以保存在证书本身所在的地方。可以让CA周期地推出CRL，然后由各个服务器删除被撤销的证书。如果目录服务器不保存证书，CRL可以被保存在网络上各个地方，只要其也被签名。

若证书有效期很长，则CRL也很长。这种情况下，可以每隔一段较长时间发行一个全列表，在这期间发行更新信息以减少分发CRL所需的带宽。

# 密码模式

一般明文被分块加密。下面假设明文$P$有$n$块，第$i$块为$P_i,0\leq i<n$，密文$C$对应的第$i$块为$C_i$。加密算法为$E$，解密算法为$E$，$IV$表示选取的初始向量（initialization vector，IV）。

## 电码本模式（electronic code book mode， ECB Mode）

电码本模式将数据块分成连续的若干块，然后用同样的密钥逐个、独立地加密这些块。

加密过程：$C_i=E(P_i),0\leq i<n$。

解密过程：$P_i=D(C_i),0\leq i<n$。

电码本模式总是将相同数据块加密为相同密文，因此入侵者可以利用这种特性攻击密码系统。除了该密码模式，下面所述的密码模式均把相同数据块加密为不同密文。

### 例

假设一家公司的员工工资由32字节长的记录序列构成，每员工一条记录，包含16字节的名字、8字节的职位与8字节的奖金，并假设每8字节使用三重DES通过电码本模式加密。那么一个表现不好的员工只需要用表现好的员工的8字节奖金的加密块替换掉自己的8字节奖金的加密块，就可期望得到更高的工资。

## 密码块链模式（cipher block chaining mode，CBC Mode）

每个明文块在加密前，先与上一个密文块执行异或操作。第一个明文块与初始向量执行异或操作。

![密码块链模式](资源\密码块链模式.png)

加密过程：$C_0=E(P_0⊕IV)$，$C_i=E(P_i⊕C_{i-1}),1\leq i<n$。

解密过程：$P_0=D(C_0)⊕IV$，$P_i=D(C_i)⊕C_{i-1},1\leq i<n$。

密码块链模式需要某个密文块完全到达时才可以对该密文块解密。

### 例

在前例中，若记录采用密码块链模式，最好再加入冗余信息（或采用ascii码表示十进制奖金数额，这样大多数ascii值都是无效的），则一个员工用表现好的员工的8字节奖金的加密块替换掉自己的8字节奖金的加密块极可能会造成从其奖金域开始的块变得没有任何意义。

## 密码反馈模式（cipher feedback mode，CFB）

密码反馈模式将明文按照小块（一般一个字节或一位）处理。该模式有一个$k$位移位寄存器，可存储$k$个小块。

![密码反馈模式](资源\密码反馈模式.png)

图（a）、图（b）分别是使用三重DES通过密码反馈模式加密、解密的过程。在（a）中，加密机处于明文第0到9个字节已经被加密并发送出去的状态，当明文第10个字节到来，DES作用于加密机的64位移位寄存器，产生64位密文，该密文最左边的字节被提取出来并与明文明文$P_{10}$异或得到密文$C_{10}$，该密文随后被放置到移位寄存器最右边，$C_2$被从左边移去。如此重复直到明文被全部加密。解密过程类似。

加密过程：当前寄存器中的内容为$C_i$，$C_{i+1}$，……，$C_{i+k-1}$分别对应第$i$到$i+k-1$个位置的明文对应的密文。下一个被加密的明文为$P_{i+k}$，则其对应的密文$C_{i+k}=E(C_i,C_{i+1},...,C_{i+k-1})_i⊕P_{i+k}$。然后寄存器中的内容变为$C_{i+1}$，$C_{i+2}$，……，$C_{i+k}$，继续上述过程加密$P_{i+k+1}$（如果有的话）。密码反馈模式需要初始向量启动整个加密过程。

解密过程：和加密类似，若下一个被解密的密文为$C_{i+k}$，则其对应的明文为$P_{i+k}=E(C_i,C_{i+1},...,C_{i+k-1})_i⊕C_{i+k}$，随后移位寄存器的内容变为$C_{i+1}$，$C_{i+2}$，……，$C_{i+k}$，继续上述过程解密$C_{i+k+1}$（如果有的话）。

如果密文一个小块的内容被破坏，接下来被解密后的$k$个位置的明文将被破坏，当坏位置被移出移位寄存器，接下来产生的明文仍是正确的。

## 流密码模式（stream cipher mode）

流密码模式使用一个密钥加密一个初始向量得到输出块，然后用同样的密钥对这个输出块加密得到第二个输出块，再对第二个输出块加密得到第三个输出块，以此类推。得到的输出块序列被称为密钥流（keystream），然后其就像一次性密钥那样与明文异或得到密文。

![流密码模式](资源\流密码模式.png)

密钥流为：$O_0=E(IV)$，$O_i=E(O_{i-1}),1\leq i<n$。

加密过程：$C_i=O_i⊕P_i,0\leq i<n$。

解密过程：$P_i=O_i⊕C_i,0\leq i<n$。

流密码模式对于同样的明文块不会输出相同的密文块，其密钥流可以被提前计算出来，与数据是独立的。

流密码模式对于错误完全不敏感，密文中的1位传输错误仅仅导致被解密出来的明文中产生同样的1位错误。

永远不要两次使用同样的（密钥，初始向量）对加密，否则两次将生成同样的密钥流，将导致密文受到密码流重用攻击。假设$P$使用密钥流$K$加密后得到$P⊕K$，$Q$使用同样的密钥流加密后得到$Q⊕K$。则入侵者捕获到这两个密文后只需要对密文进行异或$P⊕K⊕Q⊕K$，就得到$P⊕Q$，只要入侵者知道或猜到其中一个明文，则另一个明文也暴露。和替代密码与置换密码一样，明文的异或容易遭受统计攻击，因此很可能被破解。

## 计数器模式（counter mode，CTR Mode）

在该模式下，被加密的是一个常量值（对于每个明文块都有一个常量值，该常量值取决于明文块的序号），得到的密文再与明文异或得到输出。

![计数器模式](资源\计数器模式.png)

对于典型的计数器模式：

加密过程：$C_i=E(IV+i)⊕P_i,0\leq i<n$。

解密过程：$P_i=C_i⊕E(IV+i),0\leq i<n$

如果对第$i$个明文块（密文块）可以随机访问，且可以根据其对应的常量值直接得到$i$（就像在典型模式下那样），则可以对随机的块进行快速索引并解密，而不需要依赖于其他块。

与流密码模式类似，如果两个明文块使用同样的（密钥，常量）对，则会遭受密钥流重用攻击。因此密钥与常量值（典型情况下，其对应的$IV$值）应该独立、随机选取。

# 数字签名（digital signature）

数字签名要求当一方向另一方发送的签名消息必须满足以下条件：

1. 接收方可以验证发送方所声称的身份。该条件保证接收方可以确认消息确实来自预期的发送方，而不是伪装的第三方。
2. 发送方不能否认该消息的内容 。该条件保证接收方的权益。契约的任何一方以后不能否认自己签过名的特性称为不可否认（nonrepudiation）。
3. 接收方不能自己伪造该消息。该条件保证发送方的权益。

数字签名将认证与保密功能耦合在一起。

## 例

在金融系统中，顾客的计算机向银行的计算机订购一吨黄金。数字签名的条件1保证银行的计算机可以确保发出订单的计算机属于付款公司，即银行需要认证顾客的身份，同时顾客也要认证银行的身份。数字签名的条件2保证银行不被欺骗。假设银行卖了一吨黄金后，之后黄金的价格跌了下来，若签名不满足条件2，一个不诚实的顾客可以起诉银行，宣称自己从来没有发出过购买黄金的订单。数字签名的条件3保证用户的利益不受损害。否则当黄金的价格暴涨时，银行可企图构造一个“顾客要求购买一条黄金（而不是一吨黄金）”的签名消息，这样银行就可以保留剩余的黄金。

## 对称密钥签名

![使用中心权威机构的数字签名](资源\使用中心权威机构的数字签名.png)

对称密码签名的一种做法是设立一个人人信任且熟知一切的中心权威机构（记为Big Brother，或简写为BB）。每个用户选择一个密钥，并亲手把它送到BB的办公室，因此只有用户与BB才能知道该用户的私钥。

假设Alice与Bob的标识分别为$A$与$B$，且已分别将其密钥$K_A$与$K_B$交给BB，当Alice想要给Bob发送消息$P$时，她生成$K_A(B,R_A,t,P)$，其中$R_A$为Alice选择的一个随机数，$t$为时间戳，随后发送$A,K_A(B,R_A,t,P)$给BB，BB发送$K_B(A,R_A,t,P,K_{BB}(A,t,p))$给Bob，其中$K_{BB}$为BB的私钥。

假设Alice否认发送过消息$P$，Bob可以提供$K_{BB}(A,t,P)$，并请BB解密该消息。因为BB无法获得$K_{BB}$，因此他自己不可能伪造出$K_{BB}(A,t,P)$，只能是BB发送的。当BB接收$A,K_A(B,R_A,t,P)$时，他可以验证该消息确实来自Alice，因为第三方Trudy不知道$K_A$，不可能构造出该消息。因此Alice的否认无效。因此，数字签名的三个条件得以满足。

在该签名中，时间戳$t$用于保证新鲜度原则，防止第三方Trudy重放消息。$R_A$用于保证在时间戳时间范围内，可以接受Alice的新的$P$消息（只需要使用一个不同的$R_A$）。

该方法的缺点是必须有一个人人信任的BB，而且BB可以解读所有消息。

## 公开密钥签名

![使用公钥密码的数字签名](资源\使用公钥密码的数字签名.png)

使用公钥密码签名，要求公钥$E$与私钥$D$满足条件：$D(E(P))=P$与$E(D(P))=P$，其中$P$为明文。RSA具有这样的属性。假设Alice的公钥与私钥分别为$E_A$与$D_A$，Bob的公钥与私钥分别为$E_B$与$D_B$。当Alice想要给Bob发送消息$P$（同样需要包含时间戳、随机数与Bob标识等）时，她发送$C=E_B(D_A(P))$，Bob接收后通过$D_B(E_A(C))$得到$P$。

假设Alice否认发送过消息$P$，Bob可以提供$E_A(C)$，即$D_A(P)$。假设只有Alice知道$D_A$，那么只有她可能发送$D_A(P)$。但是若Alice声称其私钥$D_A$被泄漏，或者Alice改变了其密钥，那么Bob就会很难堪。

在技术中，Alice对消息的加密顺序不能改变（对应Bob的解密顺序不能改变），即不能是$C=D_A(E_B(P))$，否则Bob要想解密得到明文$P$，最后一步必须通过自己的私钥来解密$E_B(P)$，但是私钥是私有的，解密过程不被承认。

# 消息摘要（message digest）

消息摘要是一个哈希函数$MD$，其将任意长度的消息$P$映射到固定长度的位串，有4个重要特性：

- 给定$P$，很容易计算出$MD(P)$。
- 给定$MD(P)$，无法有效地得到$P$。
- 给定$P$，（几乎）无法找到$P'$，使得$MD(P')=MD(P)$。若两个不同的消息其消息摘要值相同，则称消息摘要发生碰撞。
- 明文的微小改变（如1位的翻转）也能导致完全不同的输出。

## 函数

### 安全散列算法（secure hash algorithm， SHA）

SHA算法包括SHA-1与SHA-2等，其中SHA-2又包括SHA-224、SHA-256、SHA-384、SHA-512等。

|              | SHA-1     | SHA-224   | SHA-256   | SHA-384    | SHA-512    |
| ------------ | --------- | --------- | --------- | ---------- | ---------- |
| 消息摘要长度 | $160$     | $224$     | $256$     | $384$      | $512$      |
| 消息长度     | $<2^{64}$ | $<2^{64}$ | $<2^{64}$ | $<2^{128}$ | $<2^{128}$ |
| 分组长度     | $512$     | $512$     | $512$     | $1024$     | $1024$     |
| 字长度       | $32$      | $32$      | $32$      | $64$       | $64$       |
| 步骤数       | $80$      | $64$      | $64$      | $80$       | $80$       |

SHA-1已被发现不安全（容易产生碰撞），SHA-2尤其是SHA-256现被广泛使用。

#### SHA-256

对于长度为$l$的二进制消息$M$，SHA-256都会产生一个256位的哈希值。长度表示的是二进制串的长度。在算法中，长度采用大端法表示，参与运算的数据块表示大端法数值。$+$表示模$2^{32}$加法，$∧$表示位与，$⊕$表示异或，$¬$表示按位取反，$R^n$表示右移$n$位，$S^n$表示循环右移$n$位。

消息摘要中用到的初始哈希值$H^0_i,1\leq i\leq8$为自然数中前8个素数平方根的（二进制表示的）小数部分取前32位的结果，如下：

```
0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
```

64个常数$K_i,1\leq i\leq64$为自然数中前64个素数立方根的（二进制表示的）小数部分取前32位的结果，如下：

```
0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
```

1. 对$M$进行补码处理。首先在消息末尾补上一位$1$，然后再补上$k$个$0$，其中$k$为最小的非负整数且满足：$l+1+k=448\mod 512$，得到$M_1$。

2. 在$M_1$末尾填充表示原始消息$M$的长度的64位二进制串，得到$M_2$。这约束了$M$最长为$2^{64}$。

3. 将处理后的消息$M_2$以512位为单位分块为：$M^{1},M^{2},...,M^{n}$，再将所有分块消息$M^i,1\leq i \leq n$分成长度为32的消息块$M^i_1,M^i_2,...,M^i_{16}$。

4. 对消息进行$n$次循环，其中第$i$次循环执行步骤5~6。

5. 令$h_k\leftarrow H^{i-1}_k,1\leq k\leq 8$。执行64次循环，其中第$j$次循环执行如下步骤：
   $$
   T_1\leftarrow h_8+Σ_1(h_5)+Ch(h_5,h_6,h_7)+K_j+W_j\\
   T_2\leftarrowΣ_0(a)+M_{aj}(a,b,c)\\
   h_8\leftarrow h_7\\
   h_7\leftarrow h_6\\
   h_6\leftarrow h_5\\
   h_5\leftarrow h_4+T_1\\
   h_4\leftarrow h_3\\
   h_3\leftarrow h_2\\
   h_2\leftarrow h_1\\
   h_1\leftarrow T_1+T_2
   $$


6. 令$H^i_k\leftarrow h_k+H^{i-1}_k,1\leq k\leq 8$

7. 循环完成后得到的$H^n=(H^n_1,H^n_2,...,H^n_8)$即为最终的哈希值。

8. 用到的6个逻辑函数如下：
   $$
   Ch(x,y,z)=(x∧y)(¬x∧z)\\
   M_{aj}(x,y,z)=(x∧y)⊕(x∧z)⊕(y∧z)\\
   Σ_0(x)=S^2(x)⊕S^{13}(x)⊕S^{22}(x)\\
   Σ_1(x)=S^6(x)⊕S^{11}(X)⊕S^{25}(x)\\
   σ_0(x)=S^7(x)⊕S^{18}(x)⊕R^3(x)\\
   σ_1(x)=S^{17}(x)⊕S^{19}(x)⊕R^{10}(x)
   $$

9. 扩展消息块$W_j,1\leq j\leq 64$如下：

$$
W_j=M^i_j,1\leq j\leq 16\\
W_j=σ_1(W_{j-2})+W_{j-7}+σ_0(W_{j-15})+W_{j-16},17\leq j\leq 64
$$


### MD5

MD5已被证明不安全，很容易生成碰撞。

对于长度为$l$的消息$M$，MD5都会产生一个128位的哈希值。长度表示的是二进制串的长度。在算法中，长度采用大端法表示，参与运算的数据块表示大端法数值，$+$表示模$2^{32}$加法，$∧$表示位与，$∨$表示位或，$⊕$表示异或，$¬$表示按位取反，$S^n$表示循环左移$n$位。

消息摘要中用到的初始哈希值$H^0_1$，$H^0_2$，$H^0_3$，$H^0_4$如下：

```
0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476
```

64个常数$T_i,1\leq i\leq64$等于$4294967296×|sin(i)|$的整数部分，其值如下：

```
0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391
```

定义16个常数$S_i,1\leq i \leq16$如下：

```
7, 12, 17, 22, 5, 9, 14, 20, 4, 11, 16, 23, 6, 10, 15, 21
```

定义64个索引$I_i,1\leq i\leq 64$如下：

```
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
2, 7, 12, 1, 6, 11, 16, 5, 10, 15, 4, 9, 14, 3, 8, 13,
6, 9, 12, 15, 2, 5, 8, 11, 14, 1, 4, 7, 10, 13, 16, 3,
1, 8, 15, 6, 13, 4, 11, 2, 9, 16, 7, 14, 5, 12, 3, 10
```



1. 对$M$进行补码处理。首先在消息末尾补上一位$1$，然后再补上$k$个$0$，其中$k$为最小的非负整数且满足：$l+1+k=448\mod 512$，得到$M_1$。

2. 在$M_1$末尾填充表示原始消息$M$的长度的64位二进制串，得到$M_2$。若消息长度超过64位，则只取低64位。

3. 将处理后的消息$M_2$以512位为单位分块为：$M^{1},M^{2},...,M^{n}$，再将所有分块消息$M^i,1\leq i \leq n$分成长度为32的消息块$M^i_1,M^i_2,...,M^i_{16}$。

4. 对消息进行$n$次循环，其中第$i$次循环执行步骤5~6。

5. 令$h_k\leftarrow H^{i-1}_k,1\leq k\leq 4$。执行$4×4$循环，其中第$j_1$次外循环，第$j_2$次内循环时执行如下步骤：
   $$
   h_1=F_{j_1}(h_1,h_2,h_3,h_4,M^i_{c+1},S_d,T_{c+1})\\
   h_4=F_{j_1}(h_4,h_1,h_2,h_3,M^i_{c+2},S_d,T_{c+2})\\
   h_3=F_{j_1}(h_3,h_4,h_1,h_2,M^i_{c+3},S_d,T_{c+3})\\
   h_2=F_{j_1}(h_2,h_3,h_4,h_1,M^i_{c+4},S_d,T_{c+4})\\
   $$

   其中：$F_1=ff$，$F_2=gg$，$F_3=hh$，$F_4=ii$，$c=16×(j_1-1)+4×(j_2-1)$，$d=4×(j_1-1)+j_2$。

6. 令$H^i_k\leftarrow h_k+H^{i-1}_k,1\leq k\leq 4$。

7. 循环完成后得到的$H^n=(H^n_1,H^n_2,H^n_3,H^n_4)$即为最终的哈希值。注意$H^n_k,0\leq k\leq 4$采用需小端法表示。

8. 用到的函数定义如下：
   $$
   ff(a,b,c,d,m,s,t)=b+S^s(a+f(b,c,d)+m+t)\\
   gg(a,b,c,d,m,s,t)=b+S^s(a+g(b,c,d)+m+t)\\
   hh(a,b,c,d,m,s,t)=b+S^s(a+h(b,c,d)+m+t)\\
   ii(a,b,c,d,m,s,t)=b+S^s(a+i(b,c,d)+m+t)\\
   f(x,y,z)=(x∧y)∨(¬x∧z)\\
   g(x,y,z)=(x∧z)∨(y∧¬z)\\
   h(x,y,z)=x⊕y⊕z\\
   i(x,y,z)=y⊕(x∨¬z)
   $$

## 将消息摘要用于数字签名中

计算消息摘要的速度一般远快于使用公钥算法对其加密，因此可被用来加速数字签名过程（尤其是公钥签名过程）。方法是使用$MD(P)$代替签名消息$P$，并将针对$P$的验证改为针对$MD(P)$的验证。消息摘要的4个特性保证$P$与$MD(P)$几乎是一一映射的，因此这种方法与原方法的效果几乎等价，但速度更快。

## 散列的消息认证码（Hashed Message Authentication Code，HMAC）

HMAC运算利用哈希算法，以密钥和消息作为输入，生成一个消息摘要作为输出。

# 认证（authentication）

认证通用模型：一方发起认证过程，给另一方或可信的KDC发送一条消息开始认证过程，紧跟其后的是各个方向上的其他信息交换。当消息被发送后，第三方可能截取、修改或重放这些消息以欺骗或阻碍正常通信双方。认证要求识别出这种情况。在绝大多数协议中，通信双方将建立起秘密的会话密钥（session key），用于接下来的会话过程。每次通信连接一般都采用新的随机选取的会话密钥，以减少被入侵成功的可能或降低被入侵成功带来的危害。可采用公钥密码实现认证过程并建立会话密钥，但出于性能上的考虑，所有会话过程中的数据流量都采用对称密钥加密。

很多认证协议属于质询-回应（challenge-response）协议。在该协议下，一方发送一个大随机数给另一方（质询），后者将这个随机数做一个特殊的转换后返回给前者（回应）。

假设参与认证的双方为Alice与Bob，攻击者为Trudy，其标识分别为$A$、$B$与$T$，$R_i$为质询，$K_i$为密钥，$K_S$为会话密钥，其中$i$表示所属者的标识，$K_{AB}$表示Alice与Bob共享的密钥。

## 通用规则

有4条通用规则通常有助于协议设计者陷入常见的陷阱：

1. 让发起方首先证明自己是谁。
2. 让发起方与应答方使用不同的密钥作为证明，这意味着要使用两个共享密钥$K_{AB}^1$与$K_{AB}^2$。
3. 让发起方与应答方从不同的集合中选取质询随机数。如发起方必须使用偶数，应答方必须使用奇数。
4. 使协议能够抵抗并行会话攻击，在并行会话中，一个会话中的信息会被用在另一个会话中。

即使违反这些规则中的任意一个，协议都可能被攻破。

## 基于共享密钥的认证

一种基于共享密钥的认证过程如下：Alice首先将自己的标识$A$发送给Bob，Bob发起质询$R_B$，然后Alice计算$K_{AB}(R_B)$并发送给Bob，然后向Bob发起一个质询$R_A$，Bob同样用共享密钥加密质询得到$K_{AB}$并发送给Alice。若双方均能解密对方发送的质询并得到原始结果，则认为对方是期望的通信实体。如果要建立会话密钥，则Alice可随机选取一个$K_S$，并用$K_{AB}$加密后发送给Bob。

![基于共享密钥的认证](资源\基于共享密钥的认证.png)

在简化版的认证中，Alice将$A$与质询$R_A$一起发送给Bob，Bob选择质询$R_B$，计算得到$K_{AB}(R_A)$并将两者一起发送给Alice，然后Alice将$K_{AB}(R_B)$发送给Bob，将协议将认证消息数目从5减至3。

![简化的基于共享密钥的认证](资源\简化的基于共享密钥的认证.png)

简化版的认证容易遭受反射攻击。Trudy可以冒充Alice将$A$与$R_T$发送给Bob，然后Bob返回$R_B$与$K_{AB}(R_T$)。Trudy无法使用$K_{AB}$加密$R_B$，所以她选择发起第二个会话，她将$A$与质询$R_B$发送给Bob，然后Bob返回新的质询$R_{B2}$与$K_{AB}(R_B)$。此时Trudy直接放弃第二个会话，并在继续第一个会话。她将第二个会话中得到的$K_{AB}(R_B)$返回给Bob，这样她与Bob的认证就完成了。如果Trudy获得过老的会话密钥$K_{S^{old}}$，则其可以将$K_{AB}(K_{S^{old}})$发送给Bob，这样就可以使用$K_{S^{old}}$作为新的会话密钥。简化版的协议违反了认证的所有4条通用规则。

![对简化的基于共享密钥的认证的反射攻击](资源\对简化的基于共享密钥的认证的反射攻击.png)

原始的协议也会遭受反射攻击。Alice试图向Bob发送自己的标识$A$以建立会话，但被Trudy捕获。Trudy冒充Bob与Alice发起第二个会话，她将$B$发送给Alice，Alice向Trudy发送质询$R_A$。Trudy无法使用$K_{AB}$加密$R_A$，所以她返回第一个会话，向Alice发送$R_A$，Alice返回$K_{AB}(R_A)$。然后Trudy返回第二个会话，向Alice发送$K_{AB}(R_A)$。这样在第二个会话中，Trudy就通过了Alice的验证。

此时Trudy可以取消第一个会话了，但是她还可以在第一个会话中等待Alice发送质询$R_{A2}$。Trudy切换到第二个会话，向Alice发送质询$R_{A2}$，Alice返回$K_{AB}(R_{A2})$。这样Trudy就可以在第一个会话中返回$K_{AB}(R_{A2})$了，于是在第一个会话中，Trudy也通过了Alice的验证。这样Trudy就与Alice建立两个连接了。

![对基于共享密钥的认证的反射攻击](资源\对基于共享密钥的认证的反射攻击.png)

### 使用HMAC的认证

在该认证协议中，Alice发送$R_A$给Bob，Bob返回$R_B$与$HMAC(R_A,R_B,A,B,K_{AB})$，其中$HMAC$为散列的消息认证码函数，最后Bob将$HMAC(R_A,R_B,K_{AB})$发送给Alice。

![使用HMAC的认证](资源\使用HMAC的认证.png)

该协议无法按照之前的方式被反射攻击攻破，因为$HMAC$中包含了双方选择的随机数$R_A$与$R_B$，Trudy无法控制其中至少一个值。

### 使用密码模式的认证

在该认证协议中，所有数据使用密码块链等模式被顺序加密，同样的消息被加密成不同值。即使随机数被重用，也不容易被反射攻击。

## 建立共享密钥

### Diffie-Hellman密钥交换协议

在该协议中，Alice与Bob选择两个大数$n$与$g$，且$n$与$g$满足一些特殊条件。然后Alice选择一个保密的大数$x$，Bob随机一个保密的大数$y$。Alice将$n,g,g^x\mod n$发送给Bob，Bob将$g^y\mod n$返回给Alice。最后Alice计算$(g^y\mod n)^x\mod n$，Bob计算$(g^x\mod n)^y\mod n$，这样他们就得到了共享密钥$g^{xy}\mod n$。并且在相关理论中，难以在只知道$n$、$g$、$g^x\mod n$、$g^y\mod n$的情况下计算出$x$、$y$或$g^{xy}\mod n$。

![Diffie-Hellman密钥交换](资源\Diffie-Hellman密钥交换.png)

因为Alice与Bob没有信息标识通信方是不是对方，该协议容易遭受中间人攻击或水桶队列攻击。Trudy也选择一个保密的大数$z$​，然后截获Alice发送给Bob的消息$n,g,g^x\mod n$​，将消息$n,g,g^z\mod n$​发送给Bob，Bob返回$g^y\mod n$​并被Trudy截获，最后Trudy发送$g^z\mod n$​给Alice。这样Trudy就与两者分别建立起共享密钥$g^{xz}\mod n$​与$g^{yz}\mod n$​，而Alice与Bob都以为自己和对方建立起了共享密钥。

![中间人攻击](资源\中间人攻击.png)

## 使用密钥分发中心的认证

基于共享密钥的认证的缺陷是对于每对通信方都需要至少一个共享密钥。使用KDC的认证则需要用户与KDC之间共享密钥，认证与会话密钥的管理都通过KDC来完成。

在一种协议中，假设Alice与Bob已分别将其密钥$K_A$与$K_B$交给KDC，Alice向KDC发送$A,K_A(B,K_S)$，请求与Bob建立连接。KDC随后向Bob发送$K_B(A,K_S)$给Bob。这样Alice与Bob之间就建立了连接并建立起会话密钥。

![使用KDC的认证协议](资源\使用KDC的认证协议.png)

该协议容易遭受重放攻击。Trudy可以记录KDC发送给Bob的消息请求$K_B(A,K_S)$与之后的数据流量并重放这些消息。如果这些消息用于Alice通知Bob（Bob是一个银行）给Trudy转账，那么Bob可能错误地给Trudy多次转账从而使Alice蒙受损失。

### 解决重放攻击的方法

#### 时间戳

该方法是在每个消息（的$K_A$）中包含一个时间戳并丢弃过期的消息。但是网络上的时钟不是精确同步的，因此总存在一个时间间隔使得在此期间内时间戳有效，因而可以重放消息。例如，假设Alice发送的消息包含的时间戳为$t$，由于网络延迟，Alice必须将$t$设置为比其发送该消息时的时刻稍晚的时刻，然后Trudy可快速捕获到该消息并重放给Bob，该消息到达Bob时可能仍然有效。若Bob的时钟慢于Alice的时钟，重放的可能性更大。

#### 临时值（nonce）

该方法是在每个消息（的$K_A$）中包含一个临时值，只要新消息中出现以前出现过的临时值就丢弃该消息。该方法的缺点是这些临时值必须被全部记录下来且不能丢失。可以将时间戳与临时值结合起来使用，但是这将使协议非常复杂。

### 多路径（multiway）的质询-回应协议

#### Needham-Schroeder认证协议

Needham-Schroeder协议可解决重放攻击，其一个变体的认证过程如下：Alice发送$R_A,A,B$​给KDC，其中$R_A$​是为了使Alice相信消息2是最新的，而不是被重放的；KDC返回$K_A(R_A,B,K_S,K_B(A,K_S))$​给Alice，$B$​被包含在密文中以防止$K_B$​被替换为$K_T$​，经$K_B$​加密后的票据被包含在消息中，以防止消息返回途中，Trudy用其他数据来替换此票据（使得$K_S$​被改变）；Alice然后发送$K_B(A,K_S),K_S(R_{A2})$​给Bob，其中$R_{A2}$​为Alice的一个质询，Bob返回$K_S(R_{A2}-1),R_B$​给Alice，最后Alice发送$K_S(R_B-1)$​给Bob完成认证。

![Needham-Schroeder认证协议](资源\Needham-Schroeder认证协议.png)

该协议的缺陷在于，如果Trudy获得过老的会话密钥，即某次认证过程中的$K_A(R_A,B,K_S,K_B(A,K_S))$被泄漏过，那么其可以重放之后的消息。

#### Otway-Rees认证协议

这是对Needham-Schroeder认证协议缺陷修复后的协议。一个略作修改的版本如下：Alice发送$A,B,R,K_A(A,B,R,R_A)$​给Bob，其中$R$​为被用作公共标识符的随机数；Bob发送$A,K_A(A,B,R,R_A),B,K_B(A,B,R,R_B)$​给KDC，KDC需要验证经过$K_A$​与$K_B$​加密的$R$​是否相同，如果不同则认证失败，否则KDC返回$K_A(R_A,K_S)$​给Alice，$K_B(R_B,K_S)$​给Bob。

![Otway-Rees认证协议](资源\Otway-Rees认证协议.png)

## 使用Kerberos的认证

该协议基于Needham-Schroeder协议的一个变种，其中第5版已被广泛使用，第4版在出现严重问题后最终退役。该协议假设所有的时钟都相当好地被同步。

在该协议中，涉及四个实体：

- Alice，一个客户工作站。
- 认证服务器（authentication server，AS），用于在用户登录过程中认证其身份。
- 票据发放服务器（ticket-granting server，TGS），用于发放票据。
- Bob的服务器，完成Alice请求的工作。

AS与KDC均与每个用户共享私钥。在消息1中，Alice输入其标识$A$与工作站的标识$TGS$，AS发送回来消息2：$K_A(TGS,K_S,t),K_{TGS}(A,K_S,t)$，其中$K_{TGS}$为TGS的密钥，只有AS与TGS知道；$t$表示时间戳。消息2达到Alice后，工作站请求Alice输入口令用于生成$K_A$以解密会话密钥，这样Alice成功登录。

然后，工作站迅速覆盖掉Alice的口令，此后若Trudy试图以Alice的身份登录，则其输入的密码是错误的。然后Alice发送消息3：$B,K_S(A,t),K_{TGS}(A,K_S,t)$请求联系Bob的服务器，其中$K_{TGS}(A,K_S,t)$可以保证发送方一定是Alice。随后TGS返回消息4：$K_S(B,K_{AB},t),K_B(A,B,K_{AB},t)$，其中$K_{AB}$是Alice与Bob之间的会话密钥。Trudy可以复制消息3并重放，但是其不能使用更新的时间戳代替$t$，即使Trudy极为快速重发消息3，也只能得到消息4而无法解密之。Alice给Bob发送消息5：$K_{AB}(A,t),K_B(A,B,K_{AB},t)$，Bob返回消息6：$K_{AB}(t)$给Alice。认证完成。

![第5版Kerberos认证协议](资源\第5版Kerberos认证协议.png)

如果Alice决定要跟另一个服务器Carol通话，只需要再次发送消息3~6，其中Bob的标识被替换为Carol的标识。

由于Kerberos的设计者们不期望全世界都信任同一个认证服务器，所以他们提供了对多个域（realm）的支持，每个域有自己的AS与TGS。若Alice需要访问远程域中某个服务器的票据，需要向她自己所在的域请求票据，该票据必须能够被远程域TGS接受。如果远程TGS已经向本地TGS注册过，则本地TGS将给Alice一个可用于远程TGS的有效票据。为了让两个域中的多个参与方共同完成一些工作，每个域必须信任另一个域的TGS。

## 使用公钥密码学的认证

该协议中，Alice与Bob分别通过PKI请求对方的公钥。假设Alice与Bob的公钥分别为$E_A$与$E_B$。Alice发送$E_B(A,R_A)$给Bob，Bob返回$E_A(R_A,R_B,K_S)$给Alice，最后Alice将$K_S(R_B)$发送给Bob。每次连接选择不同的$R_A$与$R_B$以防止消息被重放。

![使用公钥密码学的双向认证](资源\使用公钥密码学的双向认证.png)

# 密码分析

密码分析问题主要有三个变种：唯密文（cipher-only）问题，已知明文（known plaintext）问题与选择明文（chosen plaintext）问题。

在唯密文问题中，密码分析者得到一定量密文，但是没有得到明文。

在已知明文问题中，密码分析者得到一些匹配的密文与明文。密码能够承受攻击并不代表它就是安全的，有些情况下，密码分析者可以猜出明文的某些部分从而使得密码分析工作容易许多。例如，当你开始使用计算机时，很多计算机首先会回复”login“，这样密码分析者就可能得到明文“login”。

在选择明文问题中，密码分析者能够加密一些他自己选择的明文。

## 生日攻击（birthday attack）

生日攻击的原理是：假设消息摘要的长度为$m$，通过枚举的操作找到与某个消息消息摘要相同的另一个消息，期望需要$2^m$数量级的操作次数，但是要找到消息摘要相同的两个明文期望只需要$2^\frac{m}{2}$次操作。因此对于某个明文，只要生成$2^\frac{m}{2}$数量级的一组消息与$2^\frac{m}{2}$的另一组消息，那么两组消息就很有可能产生一对消息摘要相同的消息。

### 例

假设州立大学的计算机科学系有一个终生教员职位，并且有两个候选人：Tom与Dick。Tom知道系行政主管Marilyn非常欣赏他的工作，所以他请Marilyn为他写一封推荐信给系主任Smith，因为最终的决定权在系主任手中。

Marilyn告诉她的秘书Ellen给系主任写信，并大致描述她在信中要表达的内容，当Ellen写完信后，Marilyn会检查一遍，然后计算与签署64位摘要并将签过名的消息摘要发给Smith，而Ellen则单独将信件发送给Smith。

假设Ellen正迷恋着Dick，其会产生如下信件模式。其中模式[*A* | *B*]表示A或B取一，这样就产生了$2^{32}$种候选信件，这些信件的含义都是一致的，都表达了对Tom的强烈赞赏。

Dear Dean Smith,

This [*letter*| *message*] is to give my [*honest* | *frank*] opinion of Prof. Tom Wilson, who is [*a candidate* | *up*] for tenure [*now* | *this year*]. I have [*known* | *worked with*] Prof. Wilson for [*about* | *almost*] six years. He is an [*outstanding* | *excellent*] researcher of great [*talent* | *ability*] known [*worldwide* | *internationally*] for his [*brilliant* | *creative*] insights into [*many* | *a wide variety of*] [*difficult* | *challenging*] problems.

He is also a [*highly* | *greatly*] [*respected* | *admired*] [*teacher* | *educator*]. His students give his [*classes* | *courses*] [*rave* | *spectacular*] reviews. He is [*our* | *the Department’s*] [*most popular* | *best-loved*] [*teacher* | *instructor*].

[*In addition* | *Additionally*] Prof. Wilson is a [*gifted* | *effective*] fund raiser. His [*grants* | *contracts*] have brought a [*large* | *substantial*] amount of money into [*the* | *our*] Department. [*This money has* | *These funds have*] [*enabled* | *permitted*] us to [*pursue* | *carry out*] many [*special* | *important*] programs, [*such as* | *for example*] your State 2000 program. Without these funds we would [*be unable* | *not be able*] to continue this program, which is so [*important* | *essential*] to both of us. I strongly urge you to grant him tenure.

同样，Ellen产生如下信件模式。这样又产生了$2^{32}$种候选信件，这些信件的含义都是一致的，都表达了对Tom的强烈批判。

This [*letter* | *message*] is to give my [*honest* | *frank*] opinion of Prof. Tom Wilson, who is [*a candidate* | *up*] for tenure [*now* | *this year*]. I have [*known* | *worked with*] Tom for [*about* | *almost*] six years. He is a [*poor* | *weak*] researcher not well known in his [*field* | *area*]. His research [*hardly ever* | *rarely*] shows [*insight in* | *understanding of*] the [*key* | *major*] problems of [*the* | *our*] day.

Furthermore, he is not a [*respected* | *admired*] [*teacher* | *educator*]. His students give his [*classes* | *courses*] [*poor* | *bad* ] reviews. He is [*our* | *the Department’s*] least popular [*teacher* | *instructor*], known [*mostly* | *primarily*] within [*the*| *our*] Department for his [*tendency* | *propensity*] to [*ridicule* | *embarrass*] students [*foolish* | *imprudent*] enough to ask questions in his classes.

[*In addition* | *Additionally*] Tom is a [*poor* | *marginal*] fund raiser. His [*grants* | *contracts*] have brought only a [*meager* | *insignificant*] amount of money into [*the* | *our*] Department. Unless new [*money is* | *funds are*] quickly located, we may have to cancel some essential programs, such as your State 2000 program. Unfortunately, under these [*conditions* | *circumstances*] I cannot in good [*conscience* | *faith*] recommend him to you for [*tenure* | *a permanent position*]

Ellen可以计算出每个信件模式的$2^{32}$个信件的消息摘要，然后让第一个信件模式中某封信的消息摘要与第二个信件模式中某封信的消息摘要匹配，如果找不到这样的信件对的话可以增加更多选项再重试。假设信件分别为$A$与$B$，他将$A$发给Marilyn，Marilyn当然批准该信，但是他给Smith发送信$B$，因为两封信消息摘要一样，Smith当然认为该信件是经过Marilyn承认的。这样Tom就丢掉了该职位。

## 密码流重用攻击（keystream reuse attack）

对于某些加密方法，若两次使用同样的密钥以及其他配置，则攻击者可以根据此特性破解密码。

## 反射攻击（reflection attack）

入侵者尝试冒充期望通信方与另一通信方通信时，由于入侵者不知道期望通信方的密钥，因此无法直接回应另一通信方的质询。此时，入侵者建立一个新的连接，在该连接中，入侵者将第一次连接中另一通信方的质询发给另一通信方，这样入侵者就能获得第一次连接中的质询结果。因此，反射攻击中，入侵者将另一通信方发送的消息“反射”给另一通信方本身。

## 中间人攻击（man-in-the-middle attack）或水桶队列攻击（bucket brigade attack）

这种攻击模式是通过各种技术手段将受入侵者控制的一台计算机虚拟放置在网络连接中的两台通信计算机之间。在该攻击中，入侵者处于通信双方的中间，通信双方的流量通过入侵者进入对方。因此通信双方实际上都与入侵者通话，入侵者可以窃取、篡改消息，而通信对方都以为自己和对方在通话。

## 重放攻击（replay attack）

在该攻击模式中，入侵者将同一消息重放多次。对于不具有幂等性的消息（如转账），重放攻击会带来很大危害。

# 参考

[^1]: [Computer Networks.pdf](https://pan.baidu.com/share/link?shareid=2875054037&uk=1980714964)$\rightarrow$[Computer Networks.pdf](资源\Computer Networks.pdf)
[^1]: [(其它)-Tanenbaum & Wetherall：Computer Networks@2011 (第5版).pdf](https://474b.com/file/15169360-373041901)$\rightarrow$[(其它)-Tanenbaum & Wetherall：Computer Networks@2011 (第5版).pdf](资源\(其它)-Tanenbaum & Wetherall：Computer Networks@2011 (第5版).pdf)
[^1]: [Computer Networks, 5th Edition 9780132126953.pdf](https://n459.com/file/15677019-229589365)$\rightarrow$[Computer Networks, 5th Edition 9780132126953.pdf](资源\Computer Networks, 5th Edition 9780132126953.pdf)
[^1]: https://zh.ua1lib.org/book/2027145/ab22a4
[^1]: https://libgen.unblockit.day/book/index.php?md5=39A2B94341553B7E563856B9FB84B5B9
[^1]: https://libgen.unblockit.day/book/index.php?md5=08A33B401F6A07D14D248F68425EFF37
[^1]: https://pan.baidu.com/s/1GaTOo
[^1]: https://pan.baidu.com/share/link?shareid=470160&uk=708309941&fid=1579768577